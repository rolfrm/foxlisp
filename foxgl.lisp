;(println (foxgl:timestamp))

(defun plist-rest (lst func)
  (while lst
         (let ((fst (car lst)))
           (if (symbol? fst)
               (set! lst (cddr lst))
               (do
                (set! lst (cdr lst))
                (func fst))))))

(defun mat4-identity ()
  (let ((m (make-vector 16 (float32 0.0))))
    (vector-set! m 0 (float32 1.0))
    (vector-set! m 5 (float32 1.0))
    (vector-set! m 10 (float32 1.0))
    (vector-set! m 15 (float32 1.0))
    m
    ))

(defun mat4-translation (x y z)
  (let ((m (mat4-identity)))
    (vector-set! m 12 (float32 x))
    (vector-set! m 13 (float32 y))
    (vector-set! m 14 (float32 z))
    m))

(defun mat4-scale (x y z)
  (let ((m (mat4-identity)))
    (vector-set! m 0 (float32 x))
    (vector-set! m 5 (float32 y))
    (vector-set! m 10 (float32 z))
    m))
(defun mat3-identity ()
  (let ((m (make-vector 9 (float32 0.0))))
    (vector-set! m 0 (float32 1.0))
    (vector-set! m 4 (float32 1.0))
    (vector-set! m 8 (float32 1.0))
    m
    ))

(defun mat3-scale (x y)
  (let ((m (mat3-identity)))
    (vector-set! m 0 (float32 x))
    (vector-set! m 4 (float32 y))
    m))

(define render-model2 nil)
(defun render-model (model)
  (foxgl:init)
  (render-model2 model)
  )
(define get-framebuffer nil)
(define load-framebuffer nil)
(let ((color '(1 1 1 1))
      (transform nil)
      (framebuffer-cache (make-hashtable t nil))
      
      (polygon-cache (make-hashtable t nil))
      (cache-delete (lambda (x)
                      (println 'delete-poly)
                      (delete-polygon (cdr x))))
      (square-buffers nil)
      (render-sub-models
       (lambda (model)
         (plist-rest (cdr model) render-model2)))
      (test-tex nil)
      )
  (set! get-framebuffer
        (lambda (model)
          (hashtable-ref framebuffer-cache model)))
  (set! load-framebuffer
        (lambda (model size)
          (let ((bf (foxgl:create-framebuffer (car size) (cadr size))))
            (hashtable-set! framebuffer-cache model bf)
            bf)))
  
  (set!
   render-model2
   (lambda (model)

     (let ((sym (car model))
           (funcs ())
           (render-sub t)
           )
       (when (eq sym 'color)
         (let ((prev-color color))
         
           (match rgb (plookup (cdr model) ':rgb)
                  (set! color rgb)
                  )
           (match rgb (plookup (cdr model) ':rgba)
                  (set! color rgb)
                  )
           (set! render-sub nil)
           (render-sub-models model)
           (set! color prev-color)
         ))
       (when (eq sym 'ref)

         (render-model2 (symbol-value (cadr model) t)))
       (when (eq sym 'view)
         (match p (plookup (cdr model) :perspective)
                (let ((fov (car p))
                      (aspect (cadr p))
                      (near (caddr p))
                      (far (cadddr p))
                      (prev-tform transform))
                  (set! transform (mat4:perspective fov aspect near far))
                  (push! funcs (lambda () (set! transform prev-tform)))))
         (match p (plookup (cdr model) :orthographic)
                (let ((w (car p))
                      (h (cadr p))
                      (z (caddr p))
                      (prev-tform transform))
                  (set! transform (mat4:orthographic w h z))
                  (push! funcs (lambda () (set! transform prev-tform)))))
         
         
         )
       
       (when (eq sym 'transform)
         (let ((prev-tform transform)
               (new-transform (mat4-identity)))
           (when transform
             (math:*! new-transform new-transform transform))
           
         (match tlate (plookup (cdr model) ':translate)
                (math:*! new-transform new-transform
                         (mat4-translation (car tlate) (cadr tlate) (or (caddr tlate) 0.0)))
                )
         
         (match scale (plookup (cdr model) ':scale)
                (math:*! new-transform new-transform 
                         (mat4-scale (car scale) (cadr scale) (or (caddr scale) 1.0)))
                
                )
         (match rotation (plookup (cdr model) ':rotate)
                
                (math:*! new-transform new-transform (mat4:rotate (car rotation)
                                                                  (or (cadr rotation) 0.0)
                                                                  (or (caddr rotation) 0.0))))
         (set! transform new-transform)
         (set! render-sub nil)
         (render-sub-models model)
         (set! transform prev-tform)

         ))
       (when (eq sym 'render-callback)
         ((cadr model) model)
         )
       (when (eq sym 'unit-square)
         (foxgl:color color)
         (foxgl:transform (or transform (mat4-identity)))
         (foxgl:square)
         )
       (when (eq sym 'print)
         (println (list (cdr model) transform color)))
       (when (eq sym 'blend)
         (foxgl:blend t)
         (set! render-sub nil)
         (render-sub-models model)
         (foxgl:blend nil)
         )
       (when (eq sym 'depth)

         (foxgl:depth t)
                                        ;(println (glerror))
         (set! render-sub nil)
         (render-sub-models model)
         (foxgl:depth nil)
         )
       (when (eq sym 'text)
         (foxgl:color color)
         (foxgl:transform (or transform (mat4-identity)))

         (foxgl:blit-text (cadr model)(or transform (mat4-identity)))
         )
       (when (eq sym 'flat)
         (let ((fb (get-framebuffer model))
               (prev-transform transform)
               )
           (when (null? fb)
             (let ((s (plookup (cdr model) :size)))
               (set! fb (load-framebuffer model (or s '(100 100))))))
           (foxgl:bind-framebuffer fb)
           (set! transform nil)
           (push! funcs (lambda ()
                          (foxgl:unbind-framebuffer fb)
                          (set! transform prev-transform)
                          (unless square-buffers
                            
                            (set! square-buffers
                                  (list
                                   (foxgl:load-polygon (list-to-array '(0 0 1 0 0 1 1 1)))
                                   (foxgl:load-polygon (list-to-array '(0 0 1 0 0 1 1 1)))))
                            
                            )
                          (foxgl:bind-texture (foxgl:framebuffer-texture fb))
                          (foxgl:color color)
                          (foxgl:transform (or transform (mat4-identity)))
                          (foxgl:blend t)
                          (foxgl:blit-polygon square-buffers)
                          (foxgl:blend nil)
                          (foxgl:bind-texture nil)
                          
                          ))
           )
         )
       (when (eq sym 'polygon)
         (let ((dims 2)
               (poly (plookup (cdr model) :2d-triangle-strip)))
           (unless poly
             (set! poly (plookup (cdr model) :3d-triangle-strip))
             (set! dims 3)
             )
           (when poly
             (let ((r (hashtable-ref polygon-cache (cdr model))))
               (unless r
                 (println (list 'new-poly r))
                 (set! r (cons 'poly (foxgl:load-polygon (list-to-array poly) dims)))
                 (hashtable-set polygon-cache (cdr model) r)
                 (register-finalizer r cache-delete)
                 )
               (foxgl:color color)
               (foxgl:transform (or transform (mat4-identity)))
               (foxgl:blit-polygon (cdr r))
               )
             )))
       (when (eq sym 'hidden)
         (set! render-sub nil))
       (when render-sub
         (plist-rest (cdr model) render-model2))
       
       (map! funcall funcs)  
       ))))

(let ((m1 (mat4-translation 4 0 0))
      (m2 (mat4-translation 3 2 1)))
  (mat4:print m1)
  (println "")
  (mat4:print m2)
  (println "")

  (mat4:print (math:* m2 m1))
  (println "")
  (println "")
  )

(println (math:* (mat3-scale 2 3) (mat3-scale 4 5)))
(println lisp:*web-environment*)
(unless lisp:*web-environment*
  (thread:join (thread:start (lambda () (println 'thread!))))
  (thread:join (thread:start (lambda () (println 'thread!))))
  
  (let ((srv (tcp:listen 8893))
        (cli (tcp:connect "127.0.0.1" 8893)))
    (let ((cli2 (tcp:accept srv))
        (v (make-vector 4 1))
          (v2 (make-vector 10 (byte 0)))
        )
      (vector-set! v 0 10101010101010)
      (fd:write cli2 v)
      (println (list 'read (fd:read cli v2)))
      (println (list srv cli cli2 v2))
      
      (fd:close cli2)
      (fd:close cli)
      (fd:close srv)
      ))
  )

(defvar audio:note-low (* 12.0 8.0))
(defun audio:note-to-frequency(note)
  (* 440.0 (math:pow 2.0 (/ (rational note) 12.0)))
  )

(defun process-song(song buffer sample-rate phase speed)
  (let ((i 0)
        (sample (rational sample-rate))
        (llen (vector-length buffer))
        (phase-incr (/ 1.0 phase)))
    
    (defun rec(song)
      
      (let ((fst (car song))
            (result 0.0))
        (when (eq fst 'melody)
          (let ((lst (cdr song))
                (p phase))
            (loop lst
                  (if (< p 0.25)
                      (progn ;; found note
                        (set! result (sin (* 6.28 (* p (audio:note-to-frequency (car lst))))))          (set! lst nil)
                        
                        )
                      (progn
                        (set! lst (cdr lst))
                        (set! p (- p 0.25)))))
            )
          )
        result
        ))
    (loop (< i llen)
          (vector-set! buffer i (float32 (rec song)))
          (incf phase phase-incr)
          (incf i 1))
    ))

(define foxgl:key-up 264)
(define foxgl:key-w 87)
(define foxgl:key-a 65)
(define foxgl:key-s 83)
(define foxgl:key-d 68)

(defmacro measure(&rest body)
  `(let ((time-start (timestamp))
         (result (progn ,@body))
         (time-end (timestamp)))
    (println (list "operation took " (/ (rational (- time-end time-start)) 1000000.0)))
    result))

